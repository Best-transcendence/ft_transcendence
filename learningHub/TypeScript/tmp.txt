- Typescript
    - Introduction
        - A superset of JavaScript
            - Does all JS do
            - But also has additional features
        - Exists to add static typing to JS
            - → ensure that type of a variable can’t be change at any point of programme
        - TS can’t be understood by browsers → has to be compiled into JS by TypeScript Compiler (TSC)
    - What’s like JS
        - **Compilation target** → Compiles to JS, runs in browser/Node.js.
        - **Classes** → Syntactic sugar for JS prototypes.
        - **Error handling** → `try` / `catch` / `finally`.
        - **Memory model**
            - Objects always heap-allocated.
            - Garbage collection frees memory.
        - **Event loop & async**
            - Single-threaded event loop, async/await, promises.
        - **Operators** → `+`, , `===`, etc. are same as JS.
        - **Control flow** → `if`, `while`, `for`, `switch`.
        - **Functions** → Declared with `function`, arrow functions `() =>`.
        - **Objects/Arrays** → `{ key: value }`, `[1, 2, 3]`.
        - **Modules** → `import` / `export`.
    - Syntax
        - Type annotation operator `:`
            - Introduces type info to the compilor

                `let x: number = 42` → variable `x` has type `number`

        - `as`
            - Also determine the type of an element

                `const form = document.getElementById('signup-form') as HTMLFormElement;`

        - Non-null assertion operator (`!`)
            - Allows to “promise” to the compiler that the value isn’t NULL
            - ex. for DOM docs: `const link = document.querySelector('a')!;`
                - The `!` means: “I promise you this is **not null**.”
                - TypeScript then infers the type properly (`HTMLAnchorElement`) and lets you call `.href`
    - Types
        - TS infers types automatically → but typing is allowed for clarity/coersion
        - Regular Types
            - Primitives
                - `number` (int/float all under one type)
                - `string`
                - `boolean`
                - `bigint`
                - `symbol`
                - `null`
                - `undefined`
            - Special types
                - `any` → disables type-checking

                    `let x: **any** = 5;`

                - `unknown` → forces compiler to check for type

                    `let y: unknown = "hi";
                    y.toUpperCase(); // ❌ Error: not allowed until you prove it’s a string`

                    `if (typeof y === "string") {
                    y.toUpperCase(); // ✅ now safe
                    }`

                - `void` → as usual
                - `never` → for functions to never return (infinite loop)
            - Data structures
                - Arrays: `number[]` or `Array<number>`
                    - Must be typed (but can be union)
                - Tuples: `[string, number]`
                    - Fixed-length
                    - Ordered
                    - Must be typed (but can be union)
                    - Supports:
                        - Optional elements: `[number, number?]`
                        - Rest elements: `[string, ...boolean[]]`
                        - Readonly tuples: `readonly [string, number]`
                - Objects: `{ id: number; name: string }`
        - Advanced Types
            - Union types `|`
                - Represents a value can be one **of several types.
                - At runtime, it turns into its actual JS value

                `let value: number | string;
                value = 42;      // ok
                value = "test";  // ok`

            - Intersection types `&`
                - Represents a value must satisfy all type constraints simultaneously
                - Useful for:
                    - mixing
                    - merging

                `type A = {x: number};
                type B = {y: string};
                type C = A & B;  // must have both. At runtime, is just object {x, y}`

            - Literal types
                - Restrict values to specific constants

                `type YesNo = "yes" | "no";
                let answer: YesNo = "yes"; // only "yes" or "no"`

                - Template literals
                    - Allow to build new string literal types by concatenating/transforming other literal types.
                    - Intrinsic String Manipulation Types:
                        - `Uppercase<StringType>` → all characters uppercase
                        - `Lowercase<StringType>` → all characters lowercase
                        - `Capitalize<StringType>` → first character uppercase
                        - `Uncapitalize<StringType>` → first character lowercase
            - Readonly properties
                - Prevents reassignment at compile time

                    `type Point = { readonly x: number };
                    let p: Point = {x: 10};
                    p.x = 20; // TS error, but compiles to JS that *would work* if run`

            - Optional properties `?`
                - Allows to leave a field as `undefined` if not present

                    `type User = { name: string; age?: number };`

            - Mapped types
                - Allow to create a new type by transforming the properties of an existing type
                - Based on index signature syntax

                    `type OptionsFlags<Type> = {
                    [Property in keyof Type]: boolean;
                    };`

                    - Iterates over all keys of `Type` and changes their value type
                    - Example: turning all properties of a `Features` type into booleans
                - Can add/remove modifiers while mapping:
                    - `readonly` → control mutability
                    - `?` → control optionality
                    - Prefix with `-` to remove, `+` to add
                - Key Remapping with `as`
                    - Allows remapping property names
                    - Can filter keys using conditional types and `never`

                    `type RemoveKindField<Type> = {
                    [P in keyof Type as Exclude<P, "kind">]: Type[P]
                    };`

                - Mapped types aren’t limited to strings/numbers/symbols → can map over any union type
        - Utility types
            - Pre-built type transformers
            - Don’t exist at runtime, only in the type system
            - List:
                - `Partial<T>` → makes every property optional
                - `Required<T>` → makes every property required
                - `Pick<T, K>` → select only some properties
                - `Omit<T, K>` → remove some properties

            `type User = { name: string; age: number; active: boolean };`

            `type U1 = Partial<User>;   // { name?: string; age?: number; active?: boolean }
            type U2 = Pick<User, "name" | "age">; // { name: string; age: number }`

        - Enums
            - Contrarily to JS, TS supports `enum` types
            - Allows us to define/declare a collection of related values (numbers or strings) as a set of named constants

                `enum Direction`

                `{`

                `Up,`

                `Down,`

                `Left,`

                `Right`

                `}` → number based here, but could make it string based by defining `Up = ‘Up’,`

            - HOWEVER → union literal types are preferred today
        - Those types are checked at compile time
    - Type operators
        - `keyof`
            - Takes an object type
            - Produces a string/numeric literal union of its keys
            - If the type has a `string` or `number` index signature → `keyof` will return those types instead
        - `typeof`
            - 2 types:
                - JS’s `typeof`
                    - Checks type of a value while programme runs
                - TS’s `typeof`
                    - Used inside type annotations to capture the type of:
                        - A variable
                        - A property
                        - A function

                    `let s = "hello";
                    let n: typeof s;  // n has type string`

                    - Useful to reuse the type of an existing value
                        - Especially with utility types
                    - Can only use it on identifiers and their properties
        - `[]`
            - Can use on any type to extract the type of a property
            - Indexes can be:
                - index names/numbers
                - unions
                - `keyof`
                - type aliases

                `type I1 = Person["age" | "name"];  // string | number
                type I2 = Person[keyof Person];    // string | number | boolean`

    - Narrowing
        - When declaring a variable with a union type → TS doesn’t know which type

            → Can check it by “narrowing:

            - Type guards:
                - including checks conditions (`if`, `typeof`, `===`, etc.) to tell the programme what to do in any possible case

                `if (typeof x === "string") { ... }`

            - Truthiness narrowing

                `if (value) { ... }` or `if (!value) { ... }`

            - Equality narrowing
                - Using `===`, `!==`, `==`, `!=`

                `function example(x: string | number, y: string | boolean) {`

                `if (x === y)`

                `{
                // body`

                `}`

                `}`

            - `in` operator
                - Checks if a property exists on an object

                `function move(animal: Fish | Bird)`

                `{`

                `if ("swim" in animal)`

                `{`

                `animal.swim(); // narrowed to Fish`

                `}`

                `}`

            - `instanceof` operator
                - Checks class instances

                `if (x instanceof Date)`

            - Discriminated Unions
                - `kind` field (the *discriminant*) helps narrows automatically

                `function getArea(shape: Shape) {
                switch (shape.kind) {
                case "circle": return Math.PI * shape.radius ** 2;
                case "square": return shape.sideLength ** 2;
                }
                }`

            - The `never` Type & Exhaustiveness Checking
                - If you handle every possible case in a union, TS knows nothing remains (`never`
    - Objects
        - Much like JS
        - 3 ways to declare:
            - As a `function`

                `function greet(person: { name: string; age: number }) {}`

            - As an `interface`

                `interface Person { name: string; age: number }`

                - Define the shape of an object/class

                    `interface Drivable`

                    `{
                    drive(): void;
                    }
                    class Car implements Drivable {
                    drive() { console.log("vroom"); }
                    }`

                - Interfaces are always extendable later on:

                    ```tsx
                    interface Bear extends Animal
                    {
                      honey: boolean
                    }
                    ```

                - And can add fields later on:

                    ```tsx
                    // Re-opening the Animal interface to add a new field
                    interface Animal {
                      tail: boolean
                    }
                    ```

                - Interfaces can also contain/implement nested classes

                → Note: while Typed objects behave similarly, they can’t go through these later changes

                → TS recommends using interfaces to define objects as a rule of thumb

            - As a `type` alias

                `type Person = { name: string; age: number }`

                - Allows to make complex types reusable

                    `type ID = string | number;   // ID can be a string OR a number
                    type User = {
                    id: ID;
                    name: string;
                    isAdmin?: boolean; // ? = optional property
                    };`

                - Types can only extend using `&`
                    - `type ColorfulCircle = Colorful & Circle;`
                    - though depending on case, may lead to impossible `never`
        - Classes
            - Fields
                - Declared as
                    - `x: number;`
                    - or with initializers `x = 0;`.
                - Definite assignment operator `!` allows skipping initialization check.
            - Constructors
                - Similar to functions → can have:
                    - Parameters
                    - Defaults
                    - Overloads
                - Can’t ****have return type annotations → instance is always returned
                - For derived class, call parent constructor using `super()`
                    - Must be done BEFORE using `this`
                - Constructor can be written 2 ways:
                    - 1:

                        ```tsx
                        class Person {
                          readonly name: string; // This property is immutable - it can only be read
                          private isCool: boolean; // Can only access or modify from methods within this class
                          protected email: string; // Can access or modify from this class and subclasses
                          public pets: number; // Can access or modify from anywhere - including outside the class

                          constructor(n: string, c: boolean, e: string, p: number) {
                            this.name = n;
                            this.isCool = c;
                            this.email = e;
                            this.pets = p;
                          }

                          sayMyName() {
                            console.log(`Your not Heisenberg, you're ${this.name}`);
                          }
                        }
                        ```

                    - 2:

                        ```tsx
                        class Person {
                          constructor(
                            readonly name: string,
                            private isCool: boolean,
                            protected email: string,
                            public pets: number
                          ) {}

                          sayMyName() {
                            console.log(`Your not Heisenberg, you're ${this.name}`);
                          }
                        }
                        ```

            - Methods
                - Defined inside classes
                - Can use type annotations.
                - Must access fields with `this`
            - Access Modifiers supported by TS
                - `public`
                - `private` → is private at compile-time, not runtime
                - `protected`
                - `readonly`
            - Inheritance
                - `implements`
                    - Checks that a class satisfies an interface
                    - Does not change the class type
                    - Multiple interfaces possible
                - `extends`
                    - Derived class inherits fields/methods from base class
                    - Can override methods
                    - `super.` accesses base class methods
                - Type-only field declarations
                    - `declare` keyword allows type-checking without emitting runtime code
                - Initialization Order:
                    1. Base class fields
                    2. Base constructor
                    3. Derived class fields
                    4. Derived constructor
            - Relationships Between Classes
                - TypeScript uses **structural typing**:
                    - Classes with identical shapes are interchangeable
                    - Subtype relationships exist even without inheritance
                    - Empty classes can accept anything
        - Dictionary-like objects
            - Take only `string`, `number`, `symbol`, `template-literals` as index key
            - index signatures can be `readonly`
        - Generics can also be used with objects
    - API Contracts
        - Rules for structure/behavior between components
            - Like saying “I promise I’ll give you a `User` with `id` and `name`”.
        - Compile-time agreements → don’t exist in memory
        - Are enforced using:
            - Interfaces
                - See above
            - Abstract Classes
                - Code + abstract methods

                    `abstract class Animal {
                    eat() { console.log("nom"); }    // implemented
                    abstract makeSound(): void;      // not implemented
                    }
                    class Dog extends Animal {
                    makeSound() { console.log("woof"); }
                    }`

    - Functions
        - Declaration

            ```tsx
            function functionname(argname: argtype): returntype
            {
            	//body
            }
            ```

            - Can also declare a function without defining it just yet
                - → just state its signature
                - define it later

                ```tsx
                let sayHello: (name: string) => void;

                //code

                sayHello = (name) => {
                  console.log('Hello ' + name);
                };

                // code

                sayHello('Danny'); // Hello Danny
                ```

            - Can use `type` with functions too
        - Arrow function declaration

            ```tsx
            const functionname = (argname: argtype): returntype =>
            {
             //body
            };
            ```

            - Return value of arrow functions can be omitted - though it’s better to state it for clarity
            - Take a `;` after its definition
        - Optional argument
            - Add `?` after a param to make it optional

                ```tsx
                const add = (a: number, b: number, c?: number | string) =>
                {
                  console.log(c);

                  return a + b;
                };
                ```

        - Function overloads
            - Doable just like in C++
            - Prefer unions over overloads if possible
        - Declaring `this`
            - Can specify the type of `this` in function signatures

                `interface DB {
                filterUsers(filter: (this: User) => boolean): User[];
                }`

            - Note: doesn’t work with arrow functions
        - Decorators
            - Experimental features
            - Functions that modify classes, methods or properties
                - → like annotations, or metaprogramming
            - Syntax: `@`

                `class Person {
                @Log
                name: string = "Alice";
                }`

            - How it works:
                - TS transforms the `@function` into a function call at class creation
                - Used for wrapping/modifying class definitions on the go, at class definition time
        - Generics
            - Def:
                - Type parameter
                - Placeholder for a type → which compiler then enforce
            - Role:
                - Generics are like lighter C++ templates
                - Allow to create a component that can work with a variety of types
            - Syntax: `<T>`
            - Lets us write code once + reuse it safely for many types

                `function identity<T>(value: T): T`

                `{
                return value;
                }`

            - 2 ways to call:

                `identity<string>("hi"); // explicit
                identity("hi");         // type inference (preferred)`

            - Can provide default types

                `function create<T extends HTMLElement = HTMLDivElement>(el?: T): T {
                return el || (document.createElement("div") as T);
                }`

    - Compile-Time Checking
        - TS catches errors before runtime:
            - `null`/`undefined` issues
            - Wrong function args
            - Misused APIs
            - Typos in object keys
    - Tooling
        - Autocomplete
            - Type `obj.` in IDE to show available fields/methods
        - IntelliSense
            - Smart code suggestions
        - Refactoring
            - DE can rename functions/variables across files safely because it understands type relationships.
    - Modules/Standard Library
        - Small built-in API memory
            - arrays, maps, sets, promises, etc.
        - Other modules are to be implemented via NPM packages
    - Set up guide
        - Install

            `npm i -g typescript`

        - Compilation:
        `tsc <progrmme name>`
            - Not all errors prevent compilation → important to check IDE before
        - Config file
            - Shouls be in root dir of project
            - Used to specify:
                - Root files
                - Compiler options
                - Strictness of TS for checking project
            - Create config file:

                `tsc --init` → will create a `tsconfig.json` file in dir root

            - Most of config file options are taken care of by frameworks
    - Sources
        - https://www.freecodecamp.org/news/learn-typescript-beginners-guide/
        - https://public-files.gumroad.com/7dywz8dzkznvck7fbs9p8lx59o6q
        - https://www.typescriptlang.org/docs/handbook/
