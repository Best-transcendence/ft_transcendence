import { thisUser } from "../router";

import {
  Player,
  Bracket,
  createTwoPlayerTournament,
  createFourPlayerTournament,
  reportMatchResult,
} from "../tournament/engine";

function myName(): string {
  // fallbacks if needed
  return (thisUser?.name ?? "").trim();
}

function myPlayer(): Player {
  const name = myName() || "Me";
  return { id: "me", name }; // stable id for the local user
}

let paired = false; // were pairs generated by clicking Matchmaking?

function buildFourPlayerPairs(): [Player, Player][] {
  const me = myPlayer();
  const rest = players
    .filter(p => p.name.toLowerCase() !== me.name.toLowerCase())
    .slice(0, 3);
  const bag = shuffle(rest); // randomize the other three
  const semi1: [Player, Player] = [me, bag[0]]; // you always in Round 1
  const semi2: [Player, Player] = [bag[1], bag[2]];
  return [semi1, semi2];
}


/** Ensure "me" is first in players[], remove any duplicate of me */
function ensureMeFirst() {
  const me = myPlayer();
  // remove any existing entry whose name equals my name (case-insensitive)
  const filtered = players.filter(p => p.name.toLowerCase() !== me.name.toLowerCase());
  players = [me, ...filtered];
}

/** Sort chips to render me first visually */
function sortForRender(arr: Player[]): Player[] {
  const me = myPlayer();
  const rest = arr.filter(p => p.name.toLowerCase() !== me.name.toLowerCase());
  return [me, ...rest];
}

let plannedPairs: [Player, Player][] | null = null; // for 4p preview (randomized semis)

function currentMax(): 2 | 4 {
  return (mode === "2" ? 2 : 4);
}

function shuffle<T>(arr: T[]): T[] {
  const a = [...arr];
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

type Mode = "2" | "4";

let players: Player[] = [];
let guestCount = 1;
let mode: Mode = "2";
let bracket: Bracket | null = null;

function byId<T extends HTMLElement>(id: string) {
  const el = document.getElementById(id);
  if (!el) throw new Error(`#${id} not found`);
  return el as T;
}



function updateCounters() {
  const max = currentMax();
  byId<HTMLSpanElement>("count").textContent = String(players.length);
  byId<HTMLSpanElement>("max").textContent = String(max);

  const startBtn = byId<HTMLButtonElement>("btn-start");
  startBtn.disabled = players.length !== max;

  // disable add buttons if weâ€™re at capacity
  byId<HTMLButtonElement>("btn-add-friend").disabled = players.length >= max;
  byId<HTMLButtonElement>("btn-add-guest").disabled = players.length >= max;
}

function addPlayer(name: string) {
  const max = currentMax();
  if (players.length >= max) return;

  const trimmed = name.trim();
  if (!trimmed) return;

  // block adding myself by name
  if (trimmed.toLowerCase() === myName().toLowerCase()) return;

  // prevent duplicates by name
  if (players.some(p => p.name.toLowerCase() === trimmed.toLowerCase())) return;

  const id = `u_${Date.now()}_${Math.random().toString(36).slice(2,7)}`;
  players.push({ id, name: trimmed });

  // always re-enforce me at index 0
  ensureMeFirst();

  plannedPairs = null; // recalc 4p preview if needed
  updateCounters();
  renderMatchmakerPreview();
}

function startTournamentAndGo() {
  const max = currentMax();
  if (players.length !== max) return;

  if (max === 4) {
    if (!paired || !plannedPairs) {
      plannedPairs = buildFourPlayerPairs();
      paired = true;
    }
  } else {
    paired = true; // deterministic
  }

  startTournament();

  const payload = {
    mode,
    players,
    pairs: plannedPairs?.map(([a,b]) => [a.id, b.id]) ?? null,
  };
  localStorage.setItem("tournamentSeed", JSON.stringify(payload));
  window.location.hash = "#tournament";
}

// helper: violet "glow chip" for names (and for "?")
function createNameChip(label: string) {
  const chip = document.createElement("span");
  chip.className =
    "inline-flex items-center rounded-lg px-3 py-1 " +
    "font-semibold text-violet-100 " +                      // bold text
    "bg-violet-500/15 border border-violet-400/30 " +      // light purple bg
    "shadow-[0_0_12px_2px_#7037d355]";                      // glow behind
  chip.textContent = label;
  return chip;
}

// Helper: stacked layout for names + VS
function createStackedVsBlock(top: string, bottom: string, highlight = false) {
  const wrap = document.createElement("div");
  wrap.className = "flex flex-col items-center justify-center -mt-2";

  const baseColor = "text-violet-500"; // button purple
  const highlightGlow = highlight
    ? "drop-shadow-[0_0_6px_#9f7aea]"
    : ""; // stronger glow only for Final

  const topName = document.createElement("div");
  topName.textContent = top;
  topName.className = `font-bold text-lg ${baseColor} ${highlightGlow}`;

  const vs = document.createElement("div");
  vs.textContent = "vs";
  vs.className = "text-gray-400 my-1 text-sm";

  const bottomName = document.createElement("div");
  bottomName.textContent = bottom;
  bottomName.className = `font-bold text-lg ${baseColor} ${highlightGlow}`;

  wrap.append(topName, vs, bottomName);
  return wrap;
}

// Round Card Builder
function makeRoundCard(title: string, top: string, bottom: string, highlight = false) {
  const card = document.createElement("div");
  card.className =
    "rounded-2xl border border-violet-400/25 p-4 bg-[#271d35] " +
    "shadow-[0_0_30px_10px_#7037d333] flex flex-col justify-start min-h-[130px]";

  const head = document.createElement("div");
  head.className = "text-base text-gray-200 mb-3 font-semibold";
  head.textContent = title;

  const names = createStackedVsBlock(top, bottom, highlight);
  card.append(head, names);
  return card;
}

function renderMatchmakerPreview() {
  const host = byId<HTMLDivElement>("matchgenerator");
  host.innerHTML = "";

  const max = currentMax();

  // participants boy
  const participantsCard = document.createElement("div");
  participantsCard.className =
    "rounded-2xl border border-violet-400/20 p-4 mb-4 bg-[#271d35] shadow-[0_0_24px_4px_#7037d333]";
  host.appendChild(participantsCard);

  const participantsTitle = document.createElement("div");
  participantsTitle.className = "text-sm text-gray-300 mb-2";
  participantsTitle.textContent = "Participants";
  participantsCard.appendChild(participantsTitle);

  // chips instead of comma list
const chips = document.createElement("div");
chips.className = "flex flex-wrap gap-2";
if (players.length) {
  sortForRender(players).forEach((pl, idx) => {
    const chip = document.createElement("span");
    chip.className =
      "inline-flex items-center rounded-lg px-3 py-1 text-sm " +
      "bg-violet-500/15 text-violet-100 border border-violet-400/20";
    chip.textContent = pl.name;
    chips.appendChild(chip);
  });
} else {
    const none = document.createElement("div");
    none.className = "text-base text-gray-100";
    none.textContent = "No participants yet.";
    chips.appendChild(none);
  }
  participantsCard.appendChild(chips);

  // hint on its own line
  const hint = document.createElement("div");
  hint.className = "text-xs text-gray-400 mt-3";
  hint.textContent =
    "Youâ€™ll see your matchups once you reach the required players and press Matchmaking!";
  participantsCard.appendChild(hint);

  // if not enough players, stop here
  if (players.length < max) return;

  // matchup preview cards
  // matchup preview cards
const grid = document.createElement("div");
grid.className = "grid gap-4 w-full md:grid-cols-3";
host.appendChild(grid);

if (max === 2) {
  const [a, b] = players.slice(0, 2); // a is you
  if (paired) {
    grid.appendChild(makeRoundCard("Round 1", a.name, b.name));
    grid.appendChild(makeRoundCard("Round 2", a.name, b.name));
    grid.appendChild(makeRoundCard("Final Round", a.name, b.name, true));
  } else {
    // placeholders until you click Matchmaking
    grid.appendChild(makeRoundCard("Round 1", "?", "?"));
    grid.appendChild(makeRoundCard("Round 2", "?", "?"));
    grid.appendChild(makeRoundCard("Final Round", "?", "?", true));
  }
} else {
  // 4 players
  if (paired) {
    if (!plannedPairs) plannedPairs = buildFourPlayerPairs();
    const [s1a, s1b] = plannedPairs[0];
    const [s2a, s2b] = plannedPairs[1];

    grid.appendChild(makeRoundCard("Round 1", s1a.name, s1b.name));
    grid.appendChild(makeRoundCard("Round 2", s2a.name, s2b.name));
  } else {
    // not paired yet â†’ placeholders
    grid.appendChild(makeRoundCard("Round 1", "?", "?"));
    grid.appendChild(makeRoundCard("Round 2", "?", "?"));
  }

  grid.appendChild(makeRoundCard("Final Round", "?", "?", true));

  const note = document.createElement("div");
  note.className = "text-xs text-gray-300 mt-1";
  note.textContent = "Winners of Round 1 and Round 2 will be selected in the Final!";
  host.appendChild(note);
}

  // --- CTA: bottom-right, Tailwind purple ---
  const ctaWrap = document.createElement("div");
  ctaWrap.className = "mt-4 w-full flex justify-end";
  const cta = document.createElement("button");
  cta.className =
    "px-5 py-2 rounded-lg bg-violet-600 hover:bg-violet-500 text-white " +
    "border border-violet-400/30 shadow-[0_0_16px_2px_#7037d355]";
  cta.textContent = "Letâ€™s start ðŸ•¹ï¸";
  cta.onclick = () => startTournamentAndGo();
  ctaWrap.appendChild(cta);
  host.appendChild(ctaWrap);
}

function startTournament() {
  const max = currentMax();
  if (players.length !== max) return;

  ensureMeFirst();

  if (max === 2) {
    const pool = players.slice(0, 2) as [Player, Player];
    bracket = createTwoPlayerTournament(pool);
  } else {
    if (!plannedPairs) {
      // build as above to ensure youâ€™re in semi1
      const me = myPlayer();
      const rest = players
        .filter(p => p.name.toLowerCase() !== me.name.toLowerCase())
        .slice(0, 3);
      const bag = shuffle(rest);
      plannedPairs = [[me, bag[0]], [bag[1], bag[2]]];
    }
    const p = plannedPairs!;
    const ordered: [Player, Player, Player, Player] = [p[0][0], p[0][1], p[1][0], p[1][1]];
    bracket = createFourPlayerTournament(ordered);
  }
}



function resetPageState() {
  players = [];
  guestCount = 1;
  bracket = null;
  plannedPairs = null;
  paired = false;              // âœ… important

  ensureMeFirst();
  byId<HTMLDivElement>("matchgenerator").innerHTML = "";
  renderMatchmakerPreview();
  updateCounters();
}

function setMode(newMode: "2" | "4") {
  if (mode === newMode) return;
  mode = newMode;
  resetPageState(); // this will re-add me as Player 1
}

/** Public initializer â€” call this after you inject LobbyPageTournament() HTML into the DOM */
export function initLobbyPageTournament() {
  // initial mode (radio defaults)
  mode = (document.getElementById("mode-4") as HTMLInputElement).checked ? "4" : "2";

  // wire controls
  const friendInput = byId<HTMLInputElement>("friend-name");
  const addFriendBtn = byId<HTMLButtonElement>("btn-add-friend");
  const addGuestBtn = byId<HTMLButtonElement>("btn-add-guest");
  const startBtn = byId<HTMLButtonElement>("btn-start");
  const mode2 = byId<HTMLInputElement>("mode-2");
  const mode4 = byId<HTMLInputElement>("mode-4");
  addFriendBtn.onclick = () => {
    addPlayer(friendInput.value);
    friendInput.value = "";
  };

	const guestInput = byId<HTMLInputElement>("guest-name");
	addGuestBtn.onclick = () => {
	addPlayer(guestInput.value);
	guestInput.value = "";
	};


  mode2.onchange = () => { if (mode2.checked) setMode("2"); };
  mode4.onchange = () => { if (mode4.checked) setMode("4"); };

	startBtn.onclick = () => {
	const max = currentMax();
	if (players.length !== max) return;

	if (max === 4) {
		plannedPairs = buildFourPlayerPairs(); // (re)roll semifinals
		paired = true;
	} else {
		// 2 players: deterministic, nothing to randomize
		paired = true;
	}

	renderMatchmakerPreview(); // show the rounds now
	};

  ensureMeFirst();

  // first render
  resetPageState();
}

