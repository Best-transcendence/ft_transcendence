import { Player } from "./engine";
import {
  Mode,
  myName,
  myPlayer,
  shuffle,
  ensureMeFirst,
  sortForRender,
  byId,
  currentMax,
} from "./utils";
import { verifyUserForTournament } from "../services/api"; 

/**
 * Tournament Lobby Initialization and Management
 * 
 * This module handles the tournament lobby interface including:
 * - Player management (adding friends and guests)
 * - Tournament mode selection (2-player or 4-player)
 * - Match preview generation and display
 * - Tournament seed creation and navigation
 * - UI state management and validation
 */

// Local state management
let paired = false;                       // Flag: were pairs generated by clicking Matchmaking?
let plannedPairs: [Player, Player][] | null = null; // 4-player preview pairs (randomized semis)
let players: Player[] = [];               // Current tournament participants
let mode: Mode = "2";                     // Tournament mode (2 or 4 players)

// Tournament pairing and match generation

/**
 * Generates semifinal pairings for 4-player tournaments
 * Always places the current user in the first semifinal
 * Randomizes the other three players for fair matchups
 * @returns {[Player, Player][]} Array of semifinal pairs
 */
function buildFourPlayerPairs(): [Player, Player][] {
  const me = myPlayer();
  const rest = players
    .filter(p => p.name.toLowerCase() !== me.name.toLowerCase())
    .slice(0, 3);
  const bag = shuffle(rest); // Randomize the other three players
  
  if (bag.length < 3) return []; // Not enough players for 4-player tournament
  
  const semi1: [Player, Player] = [me, bag[0]!]; // Current user always in first semifinal
  const semi2: [Player, Player] = [bag[1]!, bag[2]!]; // Other two players in second semifinal
  return [semi1, semi2];
}

// UI state management and validation

/**
 * Updates UI counters and button states based on current player count
 * Enables/disables buttons based on tournament capacity and requirements
 */
function updateCounters() {
  const max = currentMax(mode);
  byId<HTMLSpanElement>("count").textContent = String(players.length);
  byId<HTMLSpanElement>("max").textContent = String(max);

  const startBtn = byId<HTMLButtonElement>("btn-start");
  const isFull = players.length >= max;
  
  // Enable Matchmaking button only when we have enough players
  // "Let's start" button only appears after Matchmaking is clicked (in renderMatchmakerPreview)
  startBtn.disabled = !isFull;
  
  // Disable add buttons if we're at capacity
  byId<HTMLButtonElement>("btn-add-guest").disabled = isFull;
  byId<HTMLButtonElement>("btn-add-friend").disabled = isFull;
  
  // Disable toggle buttons if we're at capacity
  byId<HTMLButtonElement>("btn-toggle-guest").disabled = isFull;
  byId<HTMLButtonElement>("btn-toggle-friend").disabled = isFull;
  
  // Disable input fields if we're at capacity
  byId<HTMLInputElement>("guest-name").disabled = isFull;
  byId<HTMLInputElement>("friend-email").disabled = isFull;
  byId<HTMLInputElement>("friend-password").disabled = isFull;
}

// Player management functions

/**
 * Shows error message to user
 * @param message - Error message to display
 */
function showErrorMessage(message: string) {
  const errorDiv = byId<HTMLDivElement>("player-error");
  errorDiv.textContent = message;
  errorDiv.classList.remove("hidden");
  
  // Hide error after 5 seconds
  setTimeout(() => {
    errorDiv.classList.add("hidden");
  }, 5000);
}

/**
 * Adds an authenticated user to the tournament
 * @param email - User email
 * @param password - User password
 */
async function addAuthenticatedPlayer(email: string, password: string) {
  const max = currentMax(mode);
  if (players.length >= max) return;

  try {
    // Verify user credentials
    const userData = await verifyUserForTournament(email, password);
    
    // Prevent adding current user
    if (userData.id === myPlayer().id) {
      showErrorMessage("You cannot add yourself to the tournament");
      return;
    }

    // Prevent duplicate authenticated users by authUserId
    if (players.some(p => p.authUserId === userData.id)) {
      showErrorMessage("This user is already in the tournament");
      return;
    }

    // Create authenticated player object
    const player: Player = {
      id: `auth_${userData.id}`,
      name: userData.name,
      isAuthenticated: true,
      authUserId: userData.id
    };

    players.push(player);
    players = ensureMeFirst(players);
    plannedPairs = null;
    updateCounters();
    renderMatchmakerPreview();
    
    // Clear form
    byId<HTMLInputElement>("friend-email").value = "";
    byId<HTMLInputElement>("friend-password").value = "";
    
  } catch (error) {
    console.error("Authentication failed:", error);
    if (error instanceof Error) {
      showErrorMessage(error.message);
    } else {
      showErrorMessage("Authentication failed. Please try again.");
    }
  }
}

/**
 * Adds a new player to the tournament
 * Validates name, prevents duplicates, and updates UI state
 * @param name - Player name to add
 */
function addPlayer(name: string) {
  const max = currentMax(mode);
  if (players.length >= max) return;

  const trimmed = name.trim();
  if (!trimmed) return;

  // Prevent adding current user by name
  if (trimmed.toLowerCase() === myName().toLowerCase()) return;

  // Prevent duplicate players by name (case-insensitive)
  if (players.some(p => p.name.toLowerCase() === trimmed.toLowerCase())) return;

  // Generate unique player ID and add to tournament
  const id = `guest_${Date.now()}_${Math.random().toString(36).slice(2,7)}`;
  players.push({ id, name: trimmed, isAuthenticated: false });

  // Ensure current user is always first in the list
  players = ensureMeFirst(players);

  plannedPairs = null; // Recalculate 4-player preview if needed
  updateCounters();
  renderMatchmakerPreview();
}

/**
 * Starts the tournament and navigates to the game
 * Creates tournament seed data and stores it in localStorage
 * Handles both 2-player and 4-player tournament initialization
 */
function startTournamentAndGo() {
  const max = currentMax(mode);
  if (players.length !== max) return;

  if (max === 4) {
    // 4-player tournament: generate pairs if not already done
    if (!paired || !plannedPairs) {
      plannedPairs = buildFourPlayerPairs();
      paired = true;
    }
  } else {
    // 2-player tournament: deterministic pairing
    paired = true;
  }

  // Create tournament seed payload
  const payload = {
    mode,
    players: players.map(p => ({
      id: p.id,
      name: p.name,
      isAuthenticated: p.isAuthenticated,
      authUserId: p.authUserId
    })),
    pairs: plannedPairs?.map(([a, b]) => [a.id, b.id]) ?? null,
  };
  
  // Store tournament configuration and navigate to game
  localStorage.setItem("tournamentSeed", JSON.stringify(payload));
  window.location.hash = "#tournament";
}


// UI component builders

/**
 * Creates a vertical "vs" display block for match previews
 * @param top - Top player name
 * @param bottom - Bottom player name
 * @param highlight - Whether to apply highlight styling
 * @returns {HTMLDivElement} Styled match display element
 */
function createStackedVsBlock(top: string, bottom: string, highlight = false) {
  const wrap = document.createElement("div");
  wrap.className = "flex flex-col items-center justify-center -mt-2";

  const baseColor = "text-violet-500";
  const highlightGlow = highlight ? "drop-shadow-[0_0_6px_#9f7aea]" : "";

  const topName = document.createElement("div");
  topName.textContent = top;
  topName.className = `font-bold text-lg ${baseColor} ${highlightGlow}`;

  const vs = document.createElement("div");
  vs.textContent = "vs";
  vs.className = "text-gray-400 my-1 text-sm";

  const bottomName = document.createElement("div");
  bottomName.textContent = bottom;
  bottomName.className = `font-bold text-lg ${baseColor} ${highlightGlow}`;

  wrap.append(topName, vs, bottomName);
  return wrap;
}

/**
 * Creates a tournament round card with match information
 * @param title - Round title (e.g., "Round 1", "Final")
 * @param top - Top player name
 * @param bottom - Bottom player name
 * @param highlight - Whether to apply highlight styling
 * @returns {HTMLDivElement} Styled round card element
 */
function makeRoundCard(title: string, top: string, bottom: string, highlight = false) {
  const card = document.createElement("div");
  card.className =
    "rounded-2xl border border-violet-400/25 p-4 bg-[#271d35] " +
    "shadow-[0_0_30px_10px_#7037d333] flex flex-col justify-start min-h-[130px]";

  const head = document.createElement("div");
  head.className = "text-base text-gray-200 mb-3 font-semibold";
  head.textContent = title;

  const names = createStackedVsBlock(top, bottom, highlight);
  card.append(head, names);
  return card;
}

// Tournament preview rendering

/**
 * Renders the tournament match preview interface
 * Shows participants, match cards, and tournament progression
 */
function renderMatchmakerPreview() {
  const host = byId<HTMLDivElement>("matchgenerator");
  host.innerHTML = "";

  const max = currentMax(mode);

  // Participants section
  const participantsCard = document.createElement("div");
  participantsCard.className =
    "rounded-2xl border border-violet-400/20 p-4 mb-4 bg-[#271d35] shadow-[0_0_24px_4px_#7037d333]";
  host.appendChild(participantsCard);

  const participantsTitle = document.createElement("div");
  participantsTitle.className = "text-sm text-gray-300 mb-2";
  participantsTitle.textContent = "Participants";
  participantsCard.appendChild(participantsTitle);

  // Player chips display
  const chips = document.createElement("div");
  chips.className = "flex flex-wrap gap-2";
  if (players.length) {
    sortForRender(players).forEach(pl => {
      const chip = document.createElement("span");
      
      // Different styling for authenticated vs guest users
      if (pl.isAuthenticated) {
        chip.className =
          "inline-flex items-center rounded-lg px-3 py-1 text-sm " +
          "bg-emerald-500/15 text-emerald-100 border border-emerald-400/20";
        chip.innerHTML = `${pl.name} <span class="ml-1">âœ“</span>`;
      } else {
        chip.className =
          "inline-flex items-center rounded-lg px-3 py-1 text-sm " +
          "bg-violet-500/15 text-violet-100 border border-violet-400/20";
        chip.textContent = pl.name;
      }
      
      chips.appendChild(chip);
    });
  } else {
    const none = document.createElement("div");
    none.className = "text-base text-gray-100";
    none.textContent = "No participants yet.";
    chips.appendChild(none);
  }
  participantsCard.appendChild(chips);

  // User instruction hint
  const hint = document.createElement("div");
  hint.className = "text-xs text-gray-400 mt-3";
  hint.textContent =
    "You will see your matchups once you reach the required players and press Matchmaking!";
  participantsCard.appendChild(hint);

  // Stop rendering if not enough players
  if (players.length < max) return;

  // Match preview cards grid
  const grid = document.createElement("div");
  grid.className = "grid gap-4 w-full md:grid-cols-3";
  host.appendChild(grid);

  if (max === 2) {
    const playerSlice = players.slice(0, 2);
    if (playerSlice.length >= 2) {
      const [a, b] = playerSlice;
      if (paired) {
        grid.appendChild(makeRoundCard("Round 1", a!.name, b!.name));
        grid.appendChild(makeRoundCard("Round 2", a!.name, b!.name));
        grid.appendChild(makeRoundCard("Final Round", a!.name, b!.name, true));
      } else {
        grid.appendChild(makeRoundCard("Round 1", "?", "?"));
        grid.appendChild(makeRoundCard("Round 2", "?", "?"));
        grid.appendChild(makeRoundCard("Final Round", "?", "?", true));
      }
    }
  } else {
    // 4 players
    if (paired) {
      if (!plannedPairs) plannedPairs = buildFourPlayerPairs();
      if (plannedPairs.length >= 2) {
        const [s1a, s1b] = plannedPairs[0]!;
        const [s2a, s2b] = plannedPairs[1]!;

        grid.appendChild(makeRoundCard("Round 1", s1a.name, s1b.name));
        grid.appendChild(makeRoundCard("Round 2", s2a.name, s2b.name));
      }
    } else {
      grid.appendChild(makeRoundCard("Round 1", "?", "?"));
      grid.appendChild(makeRoundCard("Round 2", "?", "?"));
    }

    grid.appendChild(makeRoundCard("Final Round", "?", "?", true));

    const note = document.createElement("div");
    note.className = "text-xs text-gray-300 mt-1";
    note.textContent = "Winners of Round 1 and Round 2 will be selected in the Final!";
    host.appendChild(note);
  }

  // Call-to-action button - only show after Matchmaking is clicked (paired = true)
  if (paired) {
    const ctaWrap = document.createElement("div");
    ctaWrap.className = "mt-4 w-full flex justify-end";
    const cta = document.createElement("button");
    cta.className =
      "px-5 py-2 rounded-lg bg-violet-600 hover:bg-violet-500 text-white " +
      "border border-violet-400/30 shadow-[0_0_16px_2px_#7037d355]";
    cta.textContent = "Let's start ðŸ•¹ï¸";
    cta.onclick = () => startTournamentAndGo();
    ctaWrap.appendChild(cta);
    host.appendChild(ctaWrap);
  }
}

// Page-level state management

/**
 * Resets the tournament lobby to initial state
 * Clears all players, pairs, and UI state
 */
function resetPageState() {
  players = [];
  plannedPairs = null;
  paired = false;

  players = ensureMeFirst(players);
  byId<HTMLDivElement>("matchgenerator").innerHTML = "";
  renderMatchmakerPreview();
  updateCounters();
}

/**
 * Changes tournament mode and resets state
 * @param newMode - New tournament mode ("2" or "4")
 */
function setMode(newMode: "2" | "4") {
  if (mode === newMode) return;
  mode = newMode;
  resetPageState(); // Reset and re-add current user as Player 1
}

// Public API - Tournament lobby initialization

/**
 * Initializes the tournament lobby page
 * Sets up event listeners, initial state, and UI controls
 * Must be called after injecting LobbyPageTournament() HTML
 */
export function initLobbyPageTournament() {
  // Initialize tournament mode from radio button defaults
  mode = (document.getElementById("mode-4") as HTMLInputElement).checked ? "4" : "2";

  // Get DOM elements for event binding
  const guestInput = byId<HTMLInputElement>("guest-name");
  const addGuestBtn = byId<HTMLButtonElement>("btn-add-guest");
  const friendEmailInput = byId<HTMLInputElement>("friend-email");
  const friendPasswordInput = byId<HTMLInputElement>("friend-password");
  const addFriendBtn = byId<HTMLButtonElement>("btn-add-friend");
  const startBtn = byId<HTMLButtonElement>("btn-start");
  const mode2 = byId<HTMLInputElement>("mode-2");
  const mode4 = byId<HTMLInputElement>("mode-4");

  // Toggle buttons for switching between guest and friend modes
  const toggleGuestBtn = byId<HTMLButtonElement>("btn-toggle-guest");
  const toggleFriendBtn = byId<HTMLButtonElement>("btn-toggle-friend");
  const guestInputs = byId<HTMLDivElement>("guest-inputs");
  const friendInputs = byId<HTMLDivElement>("friend-inputs");

  // Function to switch to guest mode
  function showGuestMode() {
    guestInputs.classList.remove('hidden');
    friendInputs.classList.add('hidden');
    
    // Update button styles
    toggleGuestBtn.className = "flex-1 px-3 py-2 rounded-lg text-sm font-medium transition-colors bg-violet-600 text-white border border-violet-400";
    toggleFriendBtn.className = "flex-1 px-3 py-2 rounded-lg text-sm font-medium transition-colors bg-transparent text-gray-300 border border-white/10 hover:border-violet-400";
    
    // Clear any error messages
    const errorDiv = byId<HTMLDivElement>("player-error");
    errorDiv.classList.add('hidden');
  }

  // Function to switch to friend mode
  function showFriendMode() {
    guestInputs.classList.add('hidden');
    friendInputs.classList.remove('hidden');
    
    // Update button styles
    toggleGuestBtn.className = "flex-1 px-3 py-2 rounded-lg text-sm font-medium transition-colors bg-transparent text-gray-300 border border-white/10 hover:border-violet-400";
    toggleFriendBtn.className = "flex-1 px-3 py-2 rounded-lg text-sm font-medium transition-colors bg-emerald-600 text-white border border-emerald-400";
    
    // Clear any error messages
    const errorDiv = byId<HTMLDivElement>("player-error");
    errorDiv.classList.add('hidden');
  }

  // Toggle button event listeners
  toggleGuestBtn.onclick = showGuestMode;
  toggleFriendBtn.onclick = showFriendMode;

  // Guest player addition
  addGuestBtn.addEventListener('click', (e) => {
    e.preventDefault();
    e.stopPropagation();
    
    const name = guestInput.value.trim();
    
    if (!name) {
      showErrorMessage("Please enter a guest username");
      return;
    }
    
    addPlayer(name);
    guestInput.value = "";
  });

  // Friend (existing user) addition
  addFriendBtn.addEventListener('click', (e) => {
    e.preventDefault();
    e.stopPropagation();
    
    const email = friendEmailInput.value.trim();
    const password = friendPasswordInput.value;
    
    if (!email || !password) {
      showErrorMessage("Please enter both email and password");
      return;
    }
    
    if (!email.includes('@') || !email.includes('.')) {
      showErrorMessage("Please enter a valid email address");
      return;
    }
    
    addAuthenticatedPlayer(email, password);
  });

  // Tournament mode selection
  mode2.onchange = () => { if (mode2.checked) setMode("2"); };
  mode4.onchange = () => { if (mode4.checked) setMode("4"); };

  // Matchmaking button - generates tournament pairs
  startBtn.onclick = () => {
    const max = currentMax(mode);
    if (players.length !== max) return;

    if (max === 4) {
      plannedPairs = buildFourPlayerPairs(); // Generate semifinal pairs
      paired = true;
    } else {
      paired = true; // 2-player tournament is deterministic
    }
    renderMatchmakerPreview();
  };

  // Initialize with current user and render initial state
  players = ensureMeFirst(players);
  resetPageState();
}